// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pprof

import (
	"fmt"
	"os"
	"runtime"
	"strings"
	"time"
	"unsafe"

	"internal/pprof/profile"
)

// translateCPUProfile parses binary CPU profiling stack trace data
// generated by runtime.CPUProfile() into a profile struct.
func translateCPUProfile(b []byte, startTime time.Time) (*profile.Profile, error) {
	const wordSize = unsafe.Sizeof(uintptr(0))
	const minRawProfile = 5 * wordSize // Need a minimum of 5 words.
	if uintptr(len(b)) < minRawProfile {
		return nil, fmt.Errorf("truncated profile")
	}
	n := int(uintptr(len(b)) / wordSize)
	data := ((*[1 << 28]uintptr)(unsafe.Pointer(&b[0])))[:n:n]
	period := data[3]
	data = data[5:] // skip header

	// profile initialization taken from pprof tool
	p := &profile.Profile{
		Period:     int64(period) * 1000,
		PeriodType: &profile.ValueType{Type: "cpu", Unit: "nanoseconds"},
		SampleType: []*profile.ValueType{
			{Type: "samples", Unit: "count"},
			{Type: "cpu", Unit: "nanoseconds"},
		},
		TimeNanos:     int64(startTime.UnixNano()),
		DurationNanos: time.Since(startTime).Nanoseconds(),
	}
	// Parse CPU samples from the profile.
	locs := make(map[uint64]*profile.Location)
	for len(b) > 0 {
		if len(data) < 2 || uintptr(len(data)) < 2+data[1] {
			return nil, fmt.Errorf("truncated profile")
		}
		count := data[0]
		nstk := data[1]
		if uintptr(len(data)) < 2+nstk {
			return nil, fmt.Errorf("truncated profile")
		}
		stk := data[2 : 2+nstk]
		data = data[2+nstk:]

		if count == 0 && nstk == 1 && stk[0] == 0 {
			// end of data marker
			break
		}

		sloc := make([]*profile.Location, len(stk))
		for i, addr := range stk {
			addr := uint64(addr)
			// Addresses from stack traces point to the next instruction after
			// each call.  Adjust by -1 to land somewhere on the actual call
			// (except for the leaf, which is not a call).
			if i > 0 {
				addr--
			}
			loc := locs[addr]
			if loc == nil {
				loc = &profile.Location{
					ID:      uint64(len(p.Location) + 1),
					Address: addr,
				}
				locs[addr] = loc
				p.Location = append(p.Location, loc)
			}
			sloc[i] = loc
		}
		p.Sample = append(p.Sample, &profile.Sample{
			Value:    []int64{int64(count), int64(count) * int64(p.Period)},
			Location: sloc,
		})
	}

	if runtime.GOOS == "linux" {
		if err := addMappings(p); err != nil {
			return nil, err
		}
	}
	symbolize(p)
	return p, nil
}

func addMappings(p *profile.Profile) error {
	// Parse memory map from /proc/self/maps
	f, err := os.Open("/proc/self/maps")
	if err != nil {
		return err
	}
	defer f.Close()
	return p.ParseMemoryMap(f)
}

type function interface {
	Name() string
	FileLine(pc uintptr) (string, int)
}

// funcForPC is a wrapper for runtime.FuncForPC. Defined as var for testing.
var funcForPC = func(pc uintptr) function {
	if f := runtime.FuncForPC(pc); f != nil {
		return f
	}
	return nil
}

func symbolize(p *profile.Profile) {
	fns := profileFunctionMap{}
	for _, l := range p.Location {
		pc := uintptr(l.Address)
		f := funcForPC(pc)
		if f == nil {
			continue
		}
		file, lineno := f.FileLine(pc)
		l.Line = []profile.Line{
			{
				Function: fns.findOrAddFunction(f.Name(), file, p),
				Line:     int64(lineno),
			},
		}
	}
	// Trim runtime functions. Always hide runtime.goexit. Other runtime
	// functions are only hidden for heapz when they appear at the beginning.
	isHeapz := p.PeriodType != nil && p.PeriodType.Type == "space"
	for _, s := range p.Sample {
		show := !isHeapz
		var i int
		for _, l := range s.Location {
			if len(l.Line) > 0 && l.Line[0].Function != nil {
				name := l.Line[0].Function.Name
				if name == "runtime.goexit" || !show && strings.HasPrefix(name, "runtime.") {
					continue
				}
			}
			show = true
			s.Location[i] = l
			i++
		}
		s.Location = s.Location[:i]
	}
}

type profileFunctionMap map[profile.Function]*profile.Function

func (fns profileFunctionMap) findOrAddFunction(name, filename string, p *profile.Profile) *profile.Function {
	f := profile.Function{
		Name:       name,
		SystemName: name,
		Filename:   filename,
	}
	if fp := fns[f]; fp != nil {
		return fp
	}
	fp := new(profile.Function)
	fns[f] = fp

	*fp = f
	fp.ID = uint64(len(p.Function) + 1)
	p.Function = append(p.Function, fp)
	return fp
}
